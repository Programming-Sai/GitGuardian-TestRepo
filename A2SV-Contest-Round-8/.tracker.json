[
    {
        "id": "001",
        "title": "Finding the Number of subarrays that meet a given criteria (eg. holds only -ve numbers).",
        "tag": "solved",
        "language": "python",
        "desc": "\n\nGiven an array of integers, you can perform an operation where you select any subarray and flip the signs of all its elements. The goal is to **maximize the total sum** of the array with the **minimum number of such operations**.\n\nTo achieve this, the key observation is:\n> You only need to flip **contiguous segments of negative numbers** to turn them positive.\n\nSo, the task reduces to:\n- Count how many **separate negative segments** exist in the array.\n- That count is the **minimum number of operations** required to maximize the sum.\n\n",
        "snippet": "\ndef check(n, a):\n    l = r =i = count = 0\n\n    while r < n:\n        print(a[i])\n        # printx(l, r, a[l:r+1], widths=[5])\n        while a[r] > 0:\n            count += 1\n            l = r+1\n            r += 1\n        r += 1\n        i += 1\n    return count",
        "solution-desc": "\n\nThis approach can be **generalized** for solving problems involving **segment-based operations**, where we want to count contiguous blocks of elements that satisfy a specific condition.\n\n### \u2705 General Strategy\n\n1. **Define a condition** is_target(x) that tells us whether an element should be part of a segment (e.g., x < 0 for negatives).\n2. **Scan the array**, skipping over elements that don\u2019t match the condition.\n3. Once you enter a segment that satisfies the condition, **move through it completely**, and **count it as one operation** (regardless of how many elements it contains).\n4. **Repeat** until the end of the array.\n\n### \ud83e\uddf1 Generalized Pseudocode\n\n`python\ndef count_segments(n, arr, is_target):\n    i = 0\n    count = 0\n    while i < n:\n        # Skip non-target values\n        while i < n and not is_target(arr[i]):\n            i += 1\n        # Traverse a full target segment\n        if i < n and is_target(arr[i]):\n            count += 1\n            while i < n and is_target(arr[i]):\n                i += 1\n    return count\n`\n\nThis approach is efficient because:\n- It **leverages the outcome of the inner loop** (i.e., a full pass over the segment).\n- It avoids rechecking conditions unnecessarily.\n- It\u2019s **robust to changes within the segment**, as we don't care about intermediate details\u2014just the segment\u2019s existence.\n\n### \ud83d\udca1 Example Use Cases\n\n- Count segments of **negative numbers**: lambda x: x < 0\n- Count segments of **even numbers**: lambda x: x % 2 == 0\n- Count segments of **zeros**: lambda x: x == 0\n\n",
        "solution-snippet": "\ndef check(n, a):\n    running_sum = r = count = 0\n    for x in a:\n        running_sum += (x if x >= 0 else -x)\n\n    while r < n:\n        met_neg = False\n        while r < n and a[r] <= 0:\n            # printx(r, a[r])\n            met_neg = met_neg or (a[r] < 0)\n            r += 1\n        count += met_neg\n        r += 1\n    return (running_sum, count)\n",
        "time-taken": "60"
    }
]